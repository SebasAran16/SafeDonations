{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/DefiContribute.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nerror DefiContribute__NoAdminFound();\nerror DefiContribute__NotEligibleToDoneeRequest();\nerror DefiContribute__NotDonee();\nerror DefiContribute__NotInPendingStatus();\nerror DefiContribute__NotAcceptedAsDonee();\nerror DefiContribute__NotTheDonee();\nerror DefiContribute__NotElegibleDueYourRole();\nerror DefiContribute__NotEligibleToRemoval();\nerror DefiContribute__NotEligibleToWithdraw();\n\ncontract DefiContribute is Ownable {\n    enum doneeStatus {\n        Rejected,\n        Pending,\n        Accepted,\n        Canceled,\n        Donee,\n        Eliminated\n    }\n\n    struct Donee {\n    string cause;\n    uint256 id;\n    uint256 proceeds;\n    address payable wallet;\n    string message;    \n}\n\n    mapping (address => bool) public admin;\n    mapping (address => bool) public toNewDonee;\n    mapping (address => doneeStatus) public doneeToStatus;\n    mapping (address => uint8) public addressToRequestsSent;\n    mapping (address => uint256) public doneeCandidateToFreezeTime;\n    mapping (uint256 => Donee) public idToDonee;\n    mapping (address => uint256) public addressToDoneeId;\n    mapping (uint256 => uint256) public doneeToWithdrawalFreeze;\n    mapping (uint256 => uint8) public idToRedFlags;\n\n    uint256 public doneesId = 1;\n    uint256 public randomDonationPool;\n\n    event NewAdmin(address indexed admin);\n    event AdminRevoke(address indexed admin);\n    event NewDoneeRequest(address indexed donee, string message);\n    event DoneeRequestCanceled(address indexed donee);\n    event ApprovedDonee(address indexed donee);\n    event RejectedDonee(address indexed donee);\n    event NewDonee(string cause, uint256 indexed doneeId, address indexed donee,  string message);\n    event EliminatedDonee(string cause, uint256 indexed doneeId, address indexed donee);\n    event Donation(address indexed to, address indexed from, uint indexed amount);\n    event RedFlag(string cause, uint256 indexed doneeId, address donee, address indexed admin);\n    event ReadyToRemove(string cause, uint256 indexed id, address indexed wallet);\n    event SummedToThePool(uint256 indexed amount);\n    event Withdrawal(uint256 indexed doneeId, address indexed donee,  uint256 indexed proceeds);\n\n    modifier onlyAdmin() {\n        if (admin[msg.sender] == true) {\n            _;\n        } else {\n            revert DefiContribute__NoAdminFound();\n        }\n    }\n\n    modifier onlyAcceptedDonee() {\n        if (doneeToStatus[msg.sender] == doneeStatus(2)) {\n            _;\n        } else {\n            revert DefiContribute__NotAcceptedAsDonee();\n        }\n    }\n\n    modifier onlyDonee() {\n        if (idToDonee[addressToDoneeId[msg.sender]].wallet == msg.sender ) {\n            _;\n        } else {\n            revert DefiContribute__NotDonee();\n        }\n    }\n\n    modifier notRulers() {\n        if ((owner() == msg.sender) || admin[msg.sender] == true) {\n            revert DefiContribute__NotElegibleDueYourRole();\n        }\n        _;\n    }\n\n    modifier doneeRemovalRequirements(uint256 _id, address _wallet) {\n        if (_id <= doneesId && _wallet == idToDonee[_id].wallet && idToRedFlags[_id] >= 3) {\n            _;\n        } else {\n            revert DefiContribute__NotEligibleToRemoval();\n        }\n    }\n\n    constructor() Ownable() {\n\n    }\n\n\n    function addAdmin(address _newAdmin) public onlyOwner() {\n        admin[_newAdmin] = true;\n        emit NewAdmin(_newAdmin);\n    }\n\n    function revokeAdmin (address _admin) public onlyOwner() {\n        if (admin[_admin] == true) {\n            admin[_admin] = false;\n            emit AdminRevoke(_admin);\n        } else {\n            revert DefiContribute__NoAdminFound();\n        }\n    }\n\n    /**\n     * @notice Sends a petition to be confirmed as donee, first needs to be accepted and then finished by each donee in case.\n     * It is verified that the address has not send more than 3 attempts and that if it was freezed, the time has already passed...\n     */\n    function doneePetition(string memory _message) public notRulers() returns (bool success) {\n        if (addressToRequestsSent[msg.sender] < 3 && doneeCandidateToFreezeTime[msg.sender] <= block.timestamp) {\n            addressToRequestsSent[msg.sender]++;\n            doneeToStatus[msg.sender] = doneeStatus(1);\n            emit NewDoneeRequest(msg.sender, _message);\n            return true;\n        } else {\n            revert DefiContribute__NotEligibleToDoneeRequest();\n        }\n    }\n\n    /**\n     * @notice Cancell the donee petition but does not decrease the <addressToRequestSent> for the address, also freeze the address to be able to apply again to donee for a while.\n     */\n    function cancelDoneePetition() public {\n        if (doneeToStatus[msg.sender] == doneeStatus.Pending) {\n            doneeCandidateToFreezeTime[msg.sender] = block.timestamp + 4 weeks;\n            doneeToStatus[msg.sender] = doneeStatus(3);\n            emit DoneeRequestCanceled(msg.sender);\n        } else {\n            revert DefiContribute__NotInPendingStatus();\n        }\n    }\n\n    /**\n     * @notice Approves donee to be able to finish the process to make it's profile \n     */\n    function approveDonee(address payable _donee) public onlyAdmin() {\n        if (doneeToStatus[_donee] == doneeStatus(1)) {\n            doneeToStatus[_donee] = doneeStatus(2);\n            emit ApprovedDonee(_donee);\n        } else {\n            revert DefiContribute__NotTheDonee();\n        }\n    }\n\n    function rejectDonee(address payable _donee) public onlyAdmin() {\n        if (doneeToStatus[_donee] == doneeStatus(1)) {\n            doneeCandidateToFreezeTime[_donee] = block.timestamp + 12 weeks;\n            doneeToStatus[_donee] = doneeStatus(0);\n            emit RejectedDonee(_donee);\n        } else {\n            revert DefiContribute__NotInPendingStatus();\n        }\n    }\n\n    function becomeDonee(string memory _cause, string memory _message) public onlyAcceptedDonee() {\n        idToDonee[doneesId] = Donee(_cause, doneesId, 0, payable(msg.sender), _message);\n        addressToDoneeId[msg.sender] = doneesId;\n        doneeToWithdrawalFreeze[doneesId] = block.timestamp + 4 weeks;\n        doneeToStatus[msg.sender] == doneeStatus(4);\n        emit NewDonee(_cause, doneesId, msg.sender, _message);\n        doneesId++;\n    }\n\n    /**\n     * @notice Admins can add a red flag to a donee for the sake of setting them to removal by admins for bad behaviour and giving\n     * them time to withdraw funds\n     */\n    function addRedFlag(uint256 _doneeId, address _wallet) public onlyAdmin() {\n        if (_doneeId <= doneesId && idToDonee[_doneeId]. wallet == _wallet) {\n            idToRedFlags[_doneeId]++;\n            emit RedFlag(idToDonee[_doneeId].cause, _doneeId, _wallet, msg.sender);\n            if (idToRedFlags[_doneeId] >= 3) {\n                emit ReadyToRemove(idToDonee[_doneeId].cause, _doneeId, _wallet);\n            }\n        } else {\n            revert DefiContribute__NotDonee();\n        }\n    }\n\n    /**\n     * @notice Admins can only remove a donee after 3 red flags\n     */\n    function removeDonee(uint256 _doneeId, address payable _wallet) public onlyAdmin() doneeRemovalRequirements(_doneeId, _wallet) {\n        string memory cause = idToDonee[_doneeId].cause;\n        address wallet = idToDonee[_doneeId].wallet;\n        uint256 proceeds = idToDonee[_doneeId].proceeds;\n        doneeToStatus[_wallet] == doneeStatus(5);\n        delete idToDonee[_doneeId];\n        if (proceeds > 0) {\n            randomDonationPool += proceeds;\n            emit SummedToThePool(proceeds);\n        }\n        emit EliminatedDonee(cause, _doneeId, wallet);\n    }\n\n    function donate(uint256 _doneeId, address payable _wallet) public payable {\n        if ((idToDonee[_doneeId].wallet != 0x0000000000000000000000000000000000000000) && (idToDonee[_doneeId].wallet == _wallet)) {\n            idToDonee[_doneeId].proceeds += msg.value;\n            emit Donation(_wallet, msg.sender, msg.value);\n        } else {\n            revert DefiContribute__NotTheDonee();\n        }\n    }\n\n    function withdraw() public onlyDonee() {\n        if (doneeToWithdrawalFreeze[addressToDoneeId[msg.sender]] <= block.timestamp) {\n            uint256 proceeds = idToDonee[addressToDoneeId[msg.sender]].proceeds;\n            idToDonee[addressToDoneeId[msg.sender]].proceeds = 0;\n            (bool success, ) = msg.sender.call{value: proceeds}(\"\");\n            require (success, \"Could not withdraw proceeds...\");\n            emit Withdrawal(addressToDoneeId[msg.sender], msg.sender, proceeds);\n        } else {\n            revert DefiContribute__NotEligibleToWithdraw();\n        }\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}